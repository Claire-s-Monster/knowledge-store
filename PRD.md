# Product Requirements Document: Knowledge Store MCP Server

**Project**: knowledge-store
**Version**: 0.1.0
**Status**: Draft
**Created**: 2026-01-04
**Port**: 4004 (HTTP transport)

---

## Executive Summary

The **knowledge-store** is a ChromaDB-based MCP server providing semantic search over development patterns and solutions. It serves as the global knowledge base in the session-intelligence ecosystem, receiving curated entries from knowledge-bridge and providing similarity search for both sessions and the curator daemon.

## Architecture Context

```
session-intelligence:4002 (PostgreSQL)
         │
         │ learnings
         ▼
knowledge-bridge:4003 (PostgreSQL) ◄──── curator daemon
         │                                    │
         │ promoted entries                   │ similarity queries
         ▼                                    ▼
    knowledge-store:4004 (ChromaDB)
```

| Server | Storage | Primary Purpose |
|--------|---------|-----------------|
| session-intelligence | PostgreSQL | Per-session state, decisions |
| knowledge-bridge | PostgreSQL | Orchestration, staging, webhooks |
| **knowledge-store** | **ChromaDB** | **Semantic search on patterns** |
| curator (daemon) | SQLite | Task queue, decision log |

## Design Principles

1. **ChromaDB-native**: Leverage ChromaDB's strengths (embeddings, similarity search)
2. **Simple API**: Minimal tools focused on storage and retrieval
3. **HTTP transport**: Required for cross-service communication
4. **Lean MCP pattern**: 3 meta-tools for context efficiency

## Reference Implementation

Code patterns can be adapted from:
```
~/ClaudeCode/Servers/claude-code-knowledge-framework/development/src/uckn/
├── core/atoms/semantic_search_engine.py      # Semantic search logic
├── core/atoms/multi_modal_embeddings.py      # Embedding generation
├── storage/chromadb_connector.py             # ChromaDB operations
└── mcp/universal_knowledge_server.py         # MCP server structure
```

**Note**: The UCKN codebase includes features (project DNA, tech stack matrix) not needed here. Extract only the ChromaDB and semantic search components.

---

## Data Model

### Entry Schema

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Literal

class KnowledgeEntry(BaseModel):
    """A single knowledge entry stored in ChromaDB."""

    # Identity
    id: str                          # UUID

    # Content (embedded for search)
    problem_pattern: str             # What problem this solves
    solution: str                    # The solution/pattern
    code_example: str | None = None  # Optional code snippet

    # Classification
    tags: list[str] = []             # e.g., ["python", "pytest", "async"]
    pattern_type: Literal[
        "bugfix",
        "best_practice",
        "optimization",
        "setup",
        "architecture"
    ] = "bugfix"

    # Quality metrics (updated by curator)
    times_applied: int = 0
    success_count: int = 0
    failure_count: int = 0
    quality_score: float = 0.5       # 0.0 to 1.0

    # Lifecycle
    status: Literal[
        "active",      # Normal entry
        "canonical",   # Proven pattern (high success rate)
        "archived",    # Deprecated/obsolete
        "superseded"   # Replaced by another entry
    ] = "active"
    superseded_by: str | None = None  # Entry ID if superseded

    # Provenance
    source_session: str | None = None  # session-intelligence session ID
    source_type: Literal["session", "direct", "seeded"] = "session"
    created_at: datetime
    updated_at: datetime
    last_applied_at: datetime | None = None
```

### ChromaDB Collection Structure

```python
# Collection: "knowledge_patterns"
#
# Documents: Combined text for embedding
#   f"{problem_pattern}\n\n{solution}\n\n{code_example or ''}"
#
# Metadata: All Entry fields except content
#   {
#     "id": "...",
#     "tags": ["python", "pytest"],
#     "pattern_type": "bugfix",
#     "quality_score": 0.85,
#     "status": "active",
#     ...
#   }
#
# Embeddings: Auto-generated by ChromaDB (default: all-MiniLM-L6-v2)
```

---

## Functional Requirements

### FR-1: Core CRUD Operations

#### FR-1.1: add_entry
```python
add_entry(
    problem_pattern: str,
    solution: str,
    code_example: str | None = None,
    tags: list[str] = [],
    pattern_type: str = "bugfix",
    source_session: str | None = None,
    source_type: str = "session"
) -> EntryResult
```

**Behavior**:
- Generate UUID for entry
- Create embedding from combined content
- Store in ChromaDB with metadata
- Return entry ID

#### FR-1.2: get_entry
```python
get_entry(entry_id: str) -> KnowledgeEntry | None
```

#### FR-1.3: update_entry
```python
update_entry(
    entry_id: str,
    updates: dict  # Partial update of allowed fields
) -> EntryResult
```

**Allowed update fields**:
- `quality_score`, `times_applied`, `success_count`, `failure_count`
- `status`, `superseded_by`
- `tags`, `pattern_type`

**Not allowed** (immutable after creation):
- `problem_pattern`, `solution`, `code_example` (would change embedding)
- `id`, `created_at`, `source_session`, `source_type`

#### FR-1.4: delete_entry
```python
delete_entry(entry_id: str) -> bool
```

**Note**: Prefer `update_entry(status="archived")` over hard delete.

### FR-2: Search Operations

#### FR-2.1: search (semantic)
```python
search(
    query: str,
    limit: int = 10,
    filters: dict = {}  # Optional metadata filters
) -> list[SearchResult]
```

**Filters**:
```python
filters = {
    "status": "active",           # Only active entries
    "tags": {"$contains": "python"},
    "quality_score": {"$gte": 0.5},
    "pattern_type": "bugfix"
}
```

**Response**:
```python
class SearchResult(BaseModel):
    entry: KnowledgeEntry
    similarity_score: float  # 0.0 to 1.0
```

#### FR-2.2: find_similar
```python
find_similar(
    entry_id: str,
    threshold: float = 0.85,
    limit: int = 10
) -> list[SearchResult]
```

**Purpose**: Used by curator for deduplication.

**Behavior**:
- Get embedding for specified entry
- Find entries with similarity >= threshold
- Exclude the source entry itself

#### FR-2.3: list_entries
```python
list_entries(
    filters: dict = {},
    limit: int = 100,
    offset: int = 0
) -> list[KnowledgeEntry]
```

**Purpose**: Batch operations (curator obsolescence check, etc.)

### FR-3: Analytics

#### FR-3.1: get_stats
```python
get_stats() -> StoreStats
```

**Response**:
```python
class StoreStats(BaseModel):
    total_entries: int
    entries_by_status: dict[str, int]
    entries_by_type: dict[str, int]
    avg_quality_score: float
    top_tags: list[tuple[str, int]]  # [(tag, count), ...]
```

---

## MCP Interface

### Lean 3-Tool Pattern

```python
discover_tools(pattern: str = "") -> list[ToolSummary]
get_tool_spec(tool_name: str) -> ToolSpec
execute_tool(tool_name: str, parameters: dict) -> Result
```

### Available Tools

| Tool | Category | Purpose |
|------|----------|---------|
| `add_entry` | CRUD | Add new entry |
| `get_entry` | CRUD | Retrieve by ID |
| `update_entry` | CRUD | Partial update |
| `delete_entry` | CRUD | Remove entry |
| `search` | Search | Semantic search |
| `find_similar` | Search | Similarity for dedup |
| `list_entries` | Search | Batch listing |
| `get_stats` | Analytics | Collection stats |

---

## HTTP Transport

### Endpoints

```python
# MCP over HTTP (standard)
POST /mcp                           # MCP JSON-RPC

# REST convenience endpoints (optional, for debugging)
GET  /health                        # Health check
GET  /stats                         # Collection statistics

# SSE for real-time updates (optional, for dashboard)
GET  /events                        # Server-sent events
```

### Health Endpoint

```python
GET /health

{
    "status": "healthy",
    "chromadb": "connected",
    "collection": "knowledge_patterns",
    "entry_count": 1234,
    "version": "0.1.0"
}
```

---

## Non-Functional Requirements

### NFR-1: Performance

| Operation | Target |
|-----------|--------|
| `add_entry` | < 500ms (includes embedding) |
| `get_entry` | < 50ms |
| `update_entry` | < 100ms |
| `search` (10 results) | < 200ms |
| `find_similar` | < 300ms |

### NFR-2: Storage

| Metric | Target |
|--------|--------|
| Entries supported | 100,000+ |
| Storage per entry | ~5KB average |
| Embedding model | all-MiniLM-L6-v2 (default) |
| Embedding dimension | 384 |

### NFR-3: Reliability

- ChromaDB persistence to disk (not in-memory)
- Graceful handling of ChromaDB connection issues
- Request timeout: 30s

---

## Configuration

### Environment Variables

```bash
# Server
KNOWLEDGE_STORE_PORT=4004
KNOWLEDGE_STORE_HOST=127.0.0.1

# ChromaDB
CHROMA_PERSIST_DIR=./data/chromadb
CHROMA_COLLECTION_NAME=knowledge_patterns

# Embedding (optional - ChromaDB has defaults)
EMBEDDING_MODEL=all-MiniLM-L6-v2

# Logging
LOG_LEVEL=INFO
```

---

## Project Structure

```
~/ClaudeCode/Servers/knowledge-store/development/
├── .claude/
│   └── CLAUDE.md
├── src/
│   └── knowledge_store/
│       ├── __init__.py
│       ├── __main__.py           # Entry point
│       ├── config.py             # Configuration
│       ├── models.py             # Pydantic models
│       ├── store.py              # ChromaDB operations
│       ├── server.py             # MCP server
│       └── transport/
│           ├── __init__.py
│           └── http.py           # HTTP transport
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_store.py
│   └── test_server.py
├── data/                         # Runtime (gitignored)
│   └── chromadb/
├── pyproject.toml
├── .gitignore
└── PRD.md
```

---

## Implementation Phases

### Phase 1: Foundation
- [ ] Project scaffolding with pixi
- [ ] Configuration and models
- [ ] ChromaDB store implementation
- [ ] Basic CRUD operations

### Phase 2: Search
- [ ] Semantic search implementation
- [ ] find_similar for deduplication
- [ ] Metadata filtering

### Phase 3: MCP Server
- [ ] Lean MCP interface (3 meta-tools)
- [ ] Tool implementations
- [ ] HTTP transport

### Phase 4: Testing & Polish
- [ ] Unit tests (>80% coverage)
- [ ] Integration tests
- [ ] Health endpoint
- [ ] Documentation

---

## Code Reference: UCKN Components to Adapt

### ChromaDB Connector
```
~/ClaudeCode/Servers/claude-code-knowledge-framework/development/
└── src/uckn/storage/chromadb_connector.py
```

Key patterns:
- Collection initialization
- Document insertion with metadata
- Similarity search with filters

### Semantic Search
```
~/ClaudeCode/Servers/claude-code-knowledge-framework/development/
└── src/uckn/core/atoms/semantic_search_engine.py
```

Key patterns:
- Query embedding
- Result ranking
- Score normalization

### MCP Server Structure
```
~/ClaudeCode/Servers/claude-code-knowledge-framework/development/
└── src/uckn/mcp/universal_knowledge_server.py
```

Key patterns:
- Tool registration
- Async handlers
- Error handling

**Do NOT copy**:
- `project_dna_fingerprinter.py` - code-graph-rag feature
- `tech_stack_compatibility_matrix.py` - code-graph-rag feature
- `predict_issues` functionality
- PostgreSQL/UnifiedDatabase code

---

## Success Criteria

1. **All 8 tools functional** via lean MCP interface
2. **HTTP transport** on port 4004
3. **Semantic search** returns relevant results
4. **Similarity search** works for deduplication
5. **Test coverage** >80%
6. **Performance** meets NFR targets

---

## Changelog

| Date | Change |
|------|--------|
| 2026-01-04 | Initial PRD created |
